// ─────────────────────────────────────────────────────────────
//  lib/strapi.ts — Base Strapi fetcher
//
//  SECURITY RULES:
//  ✅ STRAPI_API_TOKEN    — server-side only (NO NEXT_PUBLIC_ prefix)
//  ✅ NEXT_PUBLIC_STRAPI_API_URL — safe to expose (URL only, no secrets)
//  ✅ All server fetches use Authorization: Bearer <token>
//  ✅ Client fetches only access published public endpoints
// ─────────────────────────────────────────────────────────────

import qs from 'qs'
import { isStrapiError } from '@/types/strapi'

export const STRAPI_URL = process.env.NEXT_PUBLIC_STRAPI_API_URL ?? 'http://localhost:1337'

// Server-side token — NEVER exposed to browser
function getServerToken(): string | undefined {
  if (typeof window !== 'undefined') return undefined // safety: no client leakage
  return process.env.STRAPI_API_TOKEN
}

export interface FetchOptions {
  /** Strapi populate param — default: '*' */
  populate?: string | string[] | Record<string, unknown>
  /** Strapi filters */
  filters?: Record<string, unknown>
  /** Strapi sort e.g. ['createdAt:desc'] */
  sort?: string | string[]
  /** Pagination */
  pagination?: { page?: number; pageSize?: number }
  /** Next.js fetch config for ISR */
  next?: NextFetchRequestConfig
  /** Force no-cache (for dynamic / real-time data) */
  noCache?: boolean
}

/**
 * Build full Strapi API URL with query params
 */
export function buildStrapiUrl(path: string, options: Omit<FetchOptions, 'next' | 'noCache'> = {}): string {
  const { populate = '*', filters, sort, pagination } = options
  const query = qs.stringify(
    { populate, filters, sort, pagination },
    { encodeValuesOnly: true, skipNulls: true }
  )
  return `${STRAPI_URL}/api${path}${query ? `?${query}` : ''}`
}

/**
 * Server-side fetch with API token auth + ISR support.
 * ⚠️  Only call from Server Components, Server Actions, or Route Handlers.
 *     Never call from 'use client' files.
 */
export async function strapiFetch<T>(
  path: string,
  options: FetchOptions = {}
): Promise<T> {
  const { next, noCache, ...queryOptions } = options
  const url = buildStrapiUrl(path, queryOptions)
  const token = getServerToken()

  console.log(`[Strapi] Fetching ${path}`)
  console.log(`[Strapi]   URL: ${url}`)
  console.log(`[Strapi]   Auth: ${token ? 'Bearer token present' : 'NO TOKEN'}`)
  console.log(`[Strapi]   Cache: ${noCache ? 'no-store' : `revalidate=${next?.revalidate ?? 60}`}`)

  const headers: HeadersInit = {
    'Content-Type': 'application/json',
  }
  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }

  try {
    const res = await fetch(url, {
      headers,
      next: noCache ? undefined : { revalidate: next?.revalidate ?? 60, tags: next?.tags },
      cache: noCache ? 'no-store' : undefined,
    })

    console.log(`[Strapi] Response status: ${res.status} ${res.statusText}`)
    console.log(`[Strapi]   Content-Type: ${res.headers.get('content-type')}`)
    console.log(`[Strapi]   Content-Length: ${res.headers.get('content-length')} bytes`)

    if (!res.ok) {
      const err = await res.json().catch(() => ({}))
      const errMsg = err?.error?.message ?? res.statusText
      console.error(`[Strapi ERROR] Failed to fetch ${path}`)
      console.error(`[Strapi ERROR]   Status: ${res.status}`)
      console.error(`[Strapi ERROR]   Message: ${errMsg}`)
      console.error(`[Strapi ERROR]   Raw error:`, err)
      throw new StrapiAPIError(res.status, errMsg, path)
    }

    const json = await res.json()
    
    // Extract response structure info
    const responseKeys = Object.keys(json)
    const hasData = Array.isArray(json.data)
    const hasResults = Array.isArray(json.results)
    const dataLength = hasData ? json.data.length : hasResults ? json.results.length : 0
    
    console.log(`[Strapi] Parsed response for ${path}`)
    console.log(`[Strapi]   Keys: [${responseKeys.join(', ')}]`)
    console.log(`[Strapi]   Has data array: ${hasData} (length: ${hasData ? json.data.length : 'N/A'})`)
    console.log(`[Strapi]   Has results array: ${hasResults} (length: ${hasResults ? json.results.length : 'N/A'})`)
    console.log(`[Strapi]   Has meta: ${!!json.meta}`)
    console.log(`[Strapi]   Has pagination: ${!!(json.pagination || json.meta?.pagination)}`)

    if (isStrapiError(json)) {
      const errMsg = json.error?.message ?? 'Unknown error'
      console.error(`[Strapi ERROR] Received error response for ${path}`)
      console.error(`[Strapi ERROR]   Status: ${json.error?.status}`)
      console.error(`[Strapi ERROR]   Message: ${errMsg}`)
      throw new StrapiAPIError(json.error.status, errMsg, path)
    }

    // Normalize non-standard Strapi response: {results, pagination} → {data, meta}
    if (json && typeof json === 'object' && Array.isArray(json.results) && !Array.isArray(json.data)) {
      console.log(`[Strapi] Normalizing ${path}: Converting from {results, pagination} to {data, meta}`)
      console.log(`[Strapi]   Results count: ${json.results.length}`)
      console.log(`[Strapi]   Pagination:`, json.pagination)
      return {
        data: json.results,
        meta: { pagination: json.pagination ?? {} },
      } as T
    }

    console.log(`[Strapi] Successfully fetched ${path} (${dataLength} items)`)
    return json as T
  } catch (error) {
    if (error instanceof StrapiAPIError) throw error
    const msg = error instanceof Error ? error.message : String(error)
    console.error(`[Strapi FATAL] Error fetching ${path}`)
    console.error(`[Strapi FATAL]   Message: ${msg}`)
    console.error(`[Strapi FATAL]   Full error:`, error)
    throw new StrapiAPIError(500, msg, path)
  }
}

/**
 * Build a public asset URL from a Strapi media url field.
 * Handles both relative (/uploads/...) and absolute URLs.
 */
export function getStrapiMediaUrl(url: string | null | undefined): string | null {
  if (!url) return null
  if (url.startsWith('http')) return url
  return `${STRAPI_URL}${url}`
}

/** Legacy alias — kept for backward compat */
export const strapiImageUrl = (path: string | null | undefined) =>
  getStrapiMediaUrl(path) ?? '/images/logoo.png'

/** Custom error class for Strapi API errors */
export class StrapiAPIError extends Error {
  constructor(
    public readonly status: number,
    message: string,
    public readonly path: string
  ) {
    super(`[Strapi ${status}] ${path}: ${message}`)
    this.name = 'StrapiAPIError'
  }
}

/**
 * @deprecated Use strapiFetch() instead.
 * Kept for backward compatibility only.
 */
export async function strapiGet<T = unknown>(
  path: string,
  query?: Record<string, unknown>
): Promise<{ data: T; meta?: unknown }> {
  return strapiFetch<{ data: T; meta?: unknown }>(path, {
    ...(query ?? {}),
    noCache: true,
  })
}
